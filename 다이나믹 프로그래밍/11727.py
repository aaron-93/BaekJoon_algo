# 문제
# 2×n 직사각형을 1×2, 2×1과 2×2 타일로 채우는 방법의 수를 구하는 프로그램을 작성하시오.

# 입력
# 첫째 줄에 n이 주어진다. (1 ≤ n ≤ 1,000)

# 출력
# 첫째 줄에 2×n 크기의 직사각형을 채우는 방법의 수를 10,007로 나눈 나머지를 출력한다.

n = int(input())
dp = [0, 1, 3]

for i in range(3, n + 1):

    # 1. n은 n-1에 2*1 블록 한개를 더 붙힐 수 있기 때문에 n = (n-1) +1
    # 2. n은 n-2에 1*2 블록 2개 혹은 2*2블록을 한개 더 붙힐 수 있고, 양 옆으로 한번씩 더 할수 있기 때문에 n = (n-2)*2
    # 양 옆으로 한번씩 더 할수 있다 = '(n-2)+새로운 블록 조합 형식' and '새로운 블록 조합 + (n-2) 형식'
    # n-2에 새로운 블록을 추가하는 것과 n-1에 새로운 블록을 추가하는 가짓수는 곂치지 않기 때문에 1+2
    # 따라서 n = (n-2)*2 + (n-1)

    result = dp[i - 2] * 2 + dp[i - 1]
    dp.append(result % 10007)

print(dp[n])


# 알아둘 것
# 위와 같이 큰 문제를 작은 문제로 쪼갤 수 있으며, 작은 문제도 큰 문제와 같은 방법으로 풀 수 있고, 작은 문제들이 겹친다. (Overlapping SubProblem)
# 문제의 정답을 작은 문제의 정답으로부터 구할 수 있으며, 문제의 크기에 상관없이 어떤 한 문제의 정답은 일정하다. (Optimal Substructure)
# D[0] = 1, D[0] = 1 으로 두고 풀어야 함.
# d배열의 크기는 1001 이상 이어야 한다. 1<=N<=1000 이면 d[1000]이 존재해야 하기 때문이다.
# 출력할 때까지 다 가서 10007로 나눈 나머지를 구하면 안되는게 중간에 함수 반환 값이 int형의 범위를 넘어가기 때문이다.
# 따라서, 애초에 d[n]에 10007로 나눈 나머지를 저장해야 한다. (int형은 +-20억까지의 범위를 가지기 때문)
# 출처 : https://ldgeao99.tistory.com/283